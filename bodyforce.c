
#include "uclib.h"
#include <math.h>
#include <stdio.h> 
#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include <time.h>
#include <omp.h>
#include "OSfunc.h"
#include <process.h>
#include "parameter.h"



//[result]:the array of values returned by the user function.(Force/Volume);  [size]:the number of elements in the result array.(int);  [centroid]:網格中心點之座標;  [Velocity]:網格中心點之速度; [Iteration]:the iteration number in CoordReal precision.(int); [Angle]:船體pitch的徑度(艏仰為正); [Cell_id]:圓盤網格之編號; [Drag]:船殼阻力;
void USERFUNCTION_EXPORT bodyforce(Real(*result)[3], int size, CoordReal(*centroid)[3], CoordReal(*Velocity)[3], CoordReal(*Cell_id)[1], CoordReal(*Iteration)[1], CoordReal(*Angle)[1])
{
	
	if (size != 0)
	{
		
		
		
		struct BFKIN bfkin;
		FILE* fp5, * fp3, * fp, * fp1;
		Load_bfkin(&bfkin);
		reitestar = bfkin.itestar % bfkin.ci;
		pitch = 0;
		Output_bfkin(&bfkin, &reitestar, &pitch);

		ite = Iteration[0][0];
		//-----------------------------------------------------------------------網格參數初始化----------------------
		meshload = 0; minCellid = 999999999, np = 0, threadboy = 0, * newsize, * threadnumber, all_size = 0, non = 0;
		//----------------------------------------------------------------------------------------------------------

		//-----------------------------------------------------------------------抓取螺盤網格------------------------
		if (ite == 0) 
		{
			debug("------------ite=0--------", getpid());
			meshload = 1;//meshload=1 表示已抓取網格
			/*
			 *STEP[1]
			 *使用getpid輸出各process獨自處理的網格資料(thread_pid_ite.txt)
			 *假設有5個process在分工處理，thread資料夾便會輸出5個(thread_pid_ite.txt)對應5個不同的pid
			 *(thread_pid_ite.txt)=[網格編號,網格中心點X,網格中心點y,網格中心點z,網格中心點速度X,網格中心點速度y,網格中心點速度z]   
			 *此時minCellid在各別的process裡記錄最小的網格編號 (minCellid不是矩陣只是單變數，但在各個process裡代表該process的minCellid)
			 */			
			sprintf(str, ".\\thread\\%d_%d.txt", getpid(), ite); 			
			fp = fopen(str, "w");
			debug("STEP[1]-1   open thread file", getpid());
			fprintf(fp, "%d\n", size);
			for (i = 0; i < size; i++) 
			{
				fprintf(fp, "%lf %lf %lf %lf %lf %lf %lf\n", Cell_id[i][0], centroid[i][0], centroid[i][1], centroid[i][2], Velocity[i][0], Velocity[i][1], Velocity[i][2]);
				if (minCellid > (int)Cell_id[i][0]) 
				{
					minCellid = (int)Cell_id[i][0];
				}
			}
			fclose(fp);
			debug("STEP[1]-2   output minCellid file", getpid());			
			/*
			*STEP[2]
			*輸出各核心之minCellid
			*/			
			sprintf(str, ".\\mesh\\%d_%d.txt", getpid(), ite);
			fp1 = fopen(str, "w");
			fprintf(fp1, "%d", minCellid);
			fclose(fp1);	
			debug("STEP[2]     output minCellid file", getpid());
			/*
			 *STEP[3]
			 *計算thread資料夾下有多少檔案=有多少process在處理網格
			 */
			np = 0;
			np = count_file_num_in_a_folder(".\\thread");
			debug("STEP[3]     np calculation Done!", getpid());
			/*
			 *STEP[4]
			 *
			 *以0開始向上增加來找最小核心序，並以最小核心序核心開啟檔案(allthread.txt)紀錄各核心之核心序和size，避免其他核心開啟此檔，其他核心跳過此步驟
			 *threadboy=1表示已在最小process裡建置矩陣成功並以最小核心開啟各檔案紀錄在矩陣裡
			 */
			j = 0;
			for (i = 0; i < 99999999999; i++) 
			{
				sprintf(str, ".\\thread\\%d_%d.txt", i, ite);
				fp = fopen(str, "r");
				if (fp)
				{
					                                         
					if (i < getpid())
					{  //who is the min thread number then open file(allthread.txt)
						fclose(fp);
						break;
					}
					else
					{
						if (threadboy == 0)
						{
							threadboy = 1;
							sprintf(str, ".\\thread\\allthread%d.txt", getpid());
							fp1 = fopen(str, "w"); //輸出各核心之核心序、size
							newsize = (int*)malloc(np * sizeof(int));
							threadnumber = (int*)malloc(np * sizeof(int));
						}
					}
					fscanf(fp, "%d", &newsize[j]);
					threadnumber[j] = i; //newsize[j]儲存各核心之size threadnumber[j]=i 儲存各核心之核心序
					fprintf(fp1, "%d %d\n", threadnumber[j], newsize[j]);
					all_size = all_size + newsize[j]; //將各核心之size總和，之後會刪除重複項，使之等於圓盤網格數
					fclose(fp);
					j++;
					if (j == np) 
					{
						fclose(fp1); break;
					}
				}
			}
			debug("STEP[4]     Frist thread load done!", getpid());
			/*			 
			 *當threadboy=1時,開始建置網格矩陣		
			 *以下if判斷式裡皆由最小processID執行
			 */
			if (threadboy == 1) 
			{
				/*
				 *STEP[5]
				 * 建置2維mesh矩陣  mesh[圓盤網格數][8]
				 */
				mesh = (double**)malloc((bfkin.plane_x_numb * 4 * bfkin.plane_c_numb * bfkin.plane_r_numb) * sizeof(double*));
				for (i = 0; i != (bfkin.plane_x_numb * 4 * bfkin.plane_c_numb * bfkin.plane_r_numb); ++i) 
				{
					mesh[i] = (double*)malloc(8 * sizeof(double));
				}				
				debug("STEP[5]     MESH[][] malloc done!", getpid());

				/*
				* STEP[6]
				* 決定最小網格id並輸出,輸出後刪除
				*/				
				for (i = 0; i < np; i++) 
				{
					sprintf(str, ".\\mesh\\%d_%d.txt", threadnumber[i], ite);
					fp = fopen(str, "r");
					fscanf(fp, "%d", &numb);
					if (numb < minCellid) 
					{
						minCellid = numb;
					}
					fclose(fp);
					sprintf(str, "del .\\mesh\\%d_%d.txt", threadnumber[i], ite);
					system(str);
				}
				sprintf(str, ".\\mesh\\%d_%d.txt", getpid(), ite); //輸出minCellid file
				fp1 = fopen(".\\mesh\\minCellid.txt", "w");
				fprintf(fp1, "%d", minCellid);
				fclose(fp1);
				debug("STEP[6]     CPU data load!", getpid());

				/*
				* STEP[7]
				* 放入mesh[][]
				* 依以前紀錄之np,依序開啟各thread輸出之(thread_pid_ite.txt),假設網格數樹有22500個,對應編號須為0~22499以方便日後操作矩陣,因此kk需為22500-minCellid(1)
				* 將(thread_pid_ite.txt)裡各Cellid對應的網格資料放到mesh[id-1][x,y,z,Vx,Vy,Vz,?,?]裡,此時各(thread_pid_ite.txt)裡重複之Cellid資料會覆蓋,可得完整22500個網格資料之矩陣
				* 刪除(thread_pid_ite.txt)
				*/	
				for (i = 0; i < np; i++) 
				{
					sprintf(str, ".\\thread\\%d_%d.txt", threadnumber[i], ite);
					fp = fopen(str, "r");
					fgets(str, 200, fp);
					for (j = 0; j < newsize[i]; j++) 
					{
						fscanf(fp, "%lf", &non);
						kk = (int)non - minCellid;
						fscanf(fp, "%lf", &mesh[kk][0]);// Centroid_X
						fscanf(fp, "%lf", &mesh[kk][1]);// Centroid_Y
						fscanf(fp, "%lf", &mesh[kk][2]);// Centroid_Z
						fscanf(fp, "%lf", &mesh[kk][3]);// Vx
						fscanf(fp, "%lf", &mesh[kk][4]);// Vy
						fscanf(fp, "%lf", &mesh[kk][5]);// Vz
					}
					fclose(fp);
					sprintf(str, "del .\\thread\\%d_%d.txt", threadnumber[i], ite);
					system(str);
				}				
				debug("STEP[7]     mesh change start!", getpid());

				/*
				*STEP[8] 
				* 建立mesh矩陣裡螺盤徑向的距離及徑度 mesh[22500][6]&mesh[22500][7]
				*/
				for (i = 0; i != (bfkin.plane_x_numb * 4 * bfkin.plane_c_numb * bfkin.plane_r_numb); ++i) 
				{
					/*
					* p_xo,p_yo,p_zo為螺盤網格中心點,此時移回原點
					*/
					mesh[i][0] = mesh[i][0] - bfkin.p_xo;
					mesh[i][1] = mesh[i][1] - bfkin.p_yo;
					mesh[i][2] = mesh[i][2] - bfkin.p_zo;

					//根據推力方向 修改網格方向
					if (bfkin.bow_dir == 1)
					{
						mesh[i][0] = mesh[i][0] * (-1);
						mesh[i][1] = mesh[i][1] * (-1);
						mesh[i][3] = mesh[i][3] * (-1);
						mesh[i][4] = mesh[i][4] * (-1);
					}
					//mesh[i][6]為螺盤徑向的距離r
					//mesh[i][7]為螺盤徑向的徑度theta
					mesh[i][6] = (double)pow(pow(mesh[i][1], 2.0) + pow(mesh[i][2], 2.0), 0.5);
					if (mesh[i][1] >= 0) 
					{
						mesh[i][7] = (double)-acos(mesh[i][2] / mesh[i][6]); //徑度
					}
					else {
						mesh[i][7] = (double)acos(mesh[i][2] / mesh[i][6]); //徑度
					}
				}
				sprintf(str, "del .\\thread\\allthread%d.txt", threadnumber[0]);
				system(str);
				debug("STEP[8]     mesh load done!", getpid());
				/*
				*STEP[9] 
				*輸出mesh[ID-1][C123_V123__r_theta]文本
				*/
				sprintf(str, ".\\mesh\\mesh.txt");
				fp = fopen(str, "w");
				for (i = 0; i < (bfkin.plane_x_numb * 4 * bfkin.plane_c_numb * bfkin.plane_r_numb); i++) 
				{
					fprintf(fp, "%lf %lf %lf %lf %lf %lf %lf %lf\n", mesh[i][0], mesh[i][1], mesh[i][2], mesh[i][3], mesh[i][4], mesh[i][5], mesh[i][6], mesh[i][7]);
				}
				fclose(fp);
				debug("STEP[9]     mesh[ID-1][Cx_Cy_Cz_Vx_Vy_Vz_r_theta] output done!", getpid());
			}
			
		}
		//----------------------------------------------------------------------------------------------------------
		
		
	}
		
	



	
}
